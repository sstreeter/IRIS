import psutil
import concurrent.futures
import re
from datetime import datetime
from typing import List, Optional, Dict, Any, Tuple # ADDED: Import typing hints
import os # ADDED: Import os module

# Import necessary components from helpers.py using relative path
from ...helpers import MockAppInstance, Helpers

# --- Configurable whitelist of safe patterns ---
# This list should be comprehensive and regularly updated for real-world use.
WHITELIST_PATTERNS = [
    r'/Applications/Adobe Creative Cloud/.*',
    r'/System/Library/.*',
    r'/usr/libexec/biomesyncd',
    r'com\.apple\.',  # Apple system services
    r'/usr/bin/osascript',
    r'/usr/bin/python3',
    r'/Applications/Activity Monitor.app/.*',
    r'/Applications/Adobe Acrobat Reader DC.app/.*',
    r'/Applications/Adobe Illustrator 2023.app/.*',
    r'/Applications/Adobe Photoshop 2023.app/.*',
    r'/Applications/Archive Utility.app/.*',
    r'/Applications/Audio MIDI Setup.app/.*',
    r'/Applications/Automator.app/.*',
    r'/Applications/Books.app/.*',
    r'/Applications/Box.app/.*',
    r'/Applications/Calculator.app/.*',
    r'/Applications/Calendar.app/.*',
    r'/Applications/Chess.app/.*',
    r'/Applications/ColorSync Utility.app/.*',
    r'/Applications/Console.app/.*',
    r'/Applications/Contacts.app/.*',
    r'/Applications/Dictionary.app/.*',
    r'/Applications/Discord.app/.*',
    r'/Applications/Dropbox.app/.*',
    r'/Applications/FaceTime.app/.*',
    r'/Applications/Final Cut Pro.app/.*',
    r'/Applications/Firefox.app/.*',
    r'/Applications/Font Book.app/.*',
    r'/Applications/Google Chrome.app/.*',
    r'/Applications/Google Drive.app/.*',
    r'/Applications/Keychain Access.app/.*',
    r'/Applications/Mail.app/.*',
    r'/Applications/Maps.app/.*',
    r'/Applications/Messages.app/.*',
    r'/Applications/Music.app/.*',
    r'/Applications/Network Utility.app/.*',
    r'/Applications/News.app/.*',
    r'/Applications/Notes.app/.*',
    r'/Applications/OneDrive.app/.*',
    r'/Applications/Photos.app/.*',
    r'/Applications/Podcasts.app/.*',
    r'/Applications/Preview.app/.*',
    r'/Applications/QuickTime Player.app/.*',
    r'/Applications/Reminders.app/.*',
    r'/Applications/Safari.app/.*',
    r'/Applications/Script Editor.app/.*',
    r'/Applications/Shortcuts.app/.*',
    r'/Applications/Signal.app/.*',
    r'/Applications/Slack.app/.*',
    r'/Applications/Spotify.app/.*',
    r'/Applications/Stocks.app/.*',
    r'/Applications/System Information.app/.*',
    r'/Applications/System Preferences.app/.*',
    r'/Applications/Telegram.app/.*',
    r'/Applications/Terminal.app/.*',
    r'/Applications/Time Machine.app/.*',
    r'/Applications/TV.app/.*',
    r'/Applications/Utilities/.*',
    r'/Applications/Visual Studio Code.app/.*',
    r'/Applications/Voice Memos.app/.*',
    r'/Applications/VoiceOver Utility.app/.*',
    r'/Applications/Weather.app/.*',
    r'/Applications/Xcode.app/.*',
    r'/Applications/Zoom.us.app/.*',
    r'/Applications/1Password.app/.*',
    r'/Applications/BBEdit.app/.*',
    r'/Applications/Brave Browser.app/.*',
    r'/Library/Application Support/Adobe/.*',
    r'/Library/Application Support/Google/.*',
    r'/Library/Application Support/Box/.*',
    r'/Library/Application Support/Dropbox/.*',
    r'/Library/Application Support/OneDrive/.*',
    r'/Library/Application Support/Slack/.*',
    r'/Library/Application Support/Spotify/.*',
    r'/Library/Application Support/Zoom/.*',
    r'/Library/Application Support/1Password/.*',
    r'/Library/Application Support/BraveSoftware/Brave-Browser/.*',
    r'/Library/Application Support/Visual Studio Code/.*',
    r'/Library/Google/.*',
    r'/Library/Preferences/com\.apple\.*',
    r'/Library/Frameworks/.*',
    r'/Applications/.*',
    r'/Library/Application Support/.*',
    r'~/.vscode/.*',
    r'~/Library/Application Support/.*',
    # Add more known safe paths or command patterns here
]

def is_whitelisted(cmdline: List[str], exe_path: str) -> bool:
    """
    Returns True if cmdline or exe_path matches any whitelist pattern.
    """
    combined = ' '.join(cmdline) if isinstance(cmdline, list) else cmdline or ''
    target_strings = [combined, exe_path or '']
    for pattern in WHITELIST_PATTERNS:
        # Ensure pattern is compiled only once if performance is critical,
        # but for a small list, re.search is fine.
        regex = re.compile(pattern)
        if any(regex.search(s) for s in target_strings):
            return True
    return False

SUSPICIOUS_KEYWORDS = ['curl', 'bash', 'nc', 'wget', 'sh', 'python', 'perl', 'ruby', 'base64']

def is_suspicious_command(cmdline: List[str]) -> Tuple[bool, str]:
    """
    Checks if any suspicious keyword is in the command line.
    """
    if not cmdline:
        return False, ''
    combined = ' '.join(cmdline)
    for kw in SUSPICIOUS_KEYWORDS:
        if kw in combined:
            reason = f"Contains suspicious keyword: '{kw}'"
            return True, reason
    return False, ''

def scan_process(pid: int, app_instance: Any) -> Optional[Dict[str, Any]]:
    """
    Scans a single process for relevant information and suspicious indicators.
    """
    try:
        proc = psutil.Process(pid)
        info = {}
        info['pid'] = pid
        info['ppid'] = proc.ppid()
        info['user'] = proc.username()
        info['name'] = proc.name()
        info['cmdline'] = proc.cmdline()
        info['exe'] = proc.exe()
        info['cpu_percent'] = proc.cpu_percent(interval=0.1)
        info['memory_percent'] = proc.memory_percent()
        info['create_time'] = proc.create_time()
        
        # Deep info
        try:
            info['open_files'] = [f.path for f in proc.open_files()]
        except psutil.AccessDenied:
            info['open_files'] = ["Access Denied"]
        
        try:
            info['connections'] = [c.raddr for c in proc.connections(kind='inet') if c.raddr]
        except psutil.AccessDenied:
            info['connections'] = ["Access Denied"]

        try:
            info['cwd'] = proc.cwd()
        except psutil.AccessDenied:
            info['cwd'] = "Access Denied"

        try:
            info['environ'] = proc.environ()
        except Exception: # Catch all for environment, as it can fail
            info['environ'] = {"Error": "Access Denied or cannot retrieve"}

        # Check whitelist first
        if is_whitelisted(info['cmdline'], info['exe']):
            info['suspicious'] = False
            info['reason'] = "Whitelisted known safe process"
        else:
            suspicious, reason = is_suspicious_command(info['cmdline'])
            info['suspicious'] = suspicious
            info['reason'] = reason if suspicious else "No suspicious keywords detected"

        return info

    except (psutil.NoSuchProcess, psutil.AccessDenied) as e:
        app_instance.log_output(f"Warning: Could not scan process {pid} due to {type(e).__name__}: {e}")
        return None
    except Exception as e:
        app_instance.log_output(f"Error scanning process {pid}: {e}")
        return None

def _generate_persistence_html_content(procs_info: List[Dict[str, Any]]) -> str:
    """
    Generates the HTML table rows and summary for the persistence report.
    """
    suspicious_count = sum(1 for p in procs_info if p and p['suspicious'])
    clean_count = sum(1 for p in procs_info if p and not p['suspicious'])

    rows = ""
    for proc in procs_info:
        if not proc:
            continue
        start = datetime.fromtimestamp(proc.get("create_time", 0)).strftime("%Y-%m-%d %H:%M:%S")
        reason = proc.get('reason', 'N/A')
        suspicious_mark = "⚠️ Suspicious" if proc['suspicious'] else "✅ Clean"

        cmdline_full = ' '.join(proc['cmdline'])
        # Sanitize cmdline_full for HTML display to prevent breaking layout
        cmdline_display = cmdline_full.replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;')
        
        # Short cmdline for summary, full in details (with ellipsis)
        cmdline_short = (cmdline_display[:100] + "..." if len(cmdline_display) > 100 else cmdline_display)


        rows += f"""
        <tr class="{'suspicious' if proc['suspicious'] else 'clean'}">
            <td><button class="details-toggle" onclick="toggleDetails(this)">▶</button></td>
            <td>{proc['pid']}</td>
            <td>{proc['user']}</td>
            <td>{proc['name']}</td>
            <td title="{cmdline_display}">{cmdline_short}</td>
            <td>{proc['cpu_percent']:.2f}%</td>
            <td>{proc['memory_percent']:.2f}%</td>
            <td>{start}</td>
            <td>{suspicious_mark}</td>
        </tr>
        <tr class="details-row" style="display:none;">
            <td colspan="9">
                <strong>Reason Flagged:</strong> {reason}<br>
                <strong>Parent PID:</strong> {proc['ppid']}<br>
                <strong>Executable Path:</strong> {proc['exe']}<br>
                <strong>Current Working Directory:</strong> {proc['cwd']}<br>
                <strong>Open Files:</strong> {', '.join(f.replace('<', '&lt;').replace('>', '&gt;') for f in proc['open_files']) if proc['open_files'] else 'None'}<br>
                <strong>Network Connections:</strong> {', '.join(str(c).replace('<', '&lt;').replace('>', '&gt;') for c in proc['connections']) if proc['connections'] else 'None'}<br>
                <strong>Environment Variables (Partial):</strong> <pre style="white-space: pre-wrap; word-break: break-all;">{', '.join(f"{k}={v}".replace('<', '&lt;').replace('>', '&gt;') for k,v in proc['environ'].items()) if proc['environ'] else 'None'}</pre><br>
            </td>
        </tr>
        """

    html_content = f"""
    <h2>Process Persistence & Suspicious Activity</h2>
    <div id="summary">
        Suspicious: {suspicious_count} | Clean: {clean_count}
        <label id="filterSuspicious"><input type="checkbox" id="showSuspiciousOnly" onchange="filterSuspicious()"> Show only suspicious</label>
    </div>
    <table id="procTable">
        <thead>
            <tr>
                <th></th>
                <th onclick="sortTable(1)">PID</th>
                <th onclick="sortTable(2)">User</th>
                <th onclick="sortTable(3)">Name</th>
                <th onclick="sortTable(4)">Command Line</th>
                <th onclick="sortTable(5)">CPU %</th>
                <th onclick="sortTable(6)">Memory %</th>
                <th onclick="sortTable(7)">Start Time</th>
                <th onclick="sortTable(8)">Status</th>
            </tr>
        </thead>
        <tbody>
            {rows}
        </tbody>
    </table>
    <script>
        function toggleDetails(btn) {{
            var tr = btn.parentNode.parentNode;
            var detailsRow = tr.nextElementSibling;
            if (detailsRow.style.display === 'table-row') {{
                detailsRow.style.display = 'none';
                btn.textContent = '▶';
            }} else {{
                detailsRow.style.display = 'table-row';
                btn.textContent = '▼';
            }}
        }}

        function sortTable(n) {{
            var table = document.getElementById("procTable");
            var rows = Array.from(table.rows).slice(1); // exclude header
            var switching = true;
            var dir = "asc";
            var switchcount = 0;
            while (switching) {{
                switching = false;
                for (var i = 0; i < rows.length - 2; i += 2) {{ // Iterate by 2 to account for details rows
                    var x = rows[i].cells[n].textContent.toLowerCase();
                    var y = rows[i + 2].cells[n].textContent.toLowerCase();
                    var shouldSwitch = false;
                    if (dir === "asc") {{
                        if (x > y) {{
                            shouldSwitch = true;
                        }}
                    }} else if (dir === "desc") {{
                        if (x < y) {{
                            shouldSwitch = true;
                        }}
                    }}
                    if (shouldSwitch) {{
                        table.tBodies[0].insertBefore(rows[i + 2], rows[i]);
                        table.tBodies[0].insertBefore(rows[i + 3], rows[i + 1]); // Also move the details row
                        switching = true;
                        switchcount++;
                        break;
                    }}
                }}
                if (switchcount === 0 && dir === "asc") {{
                    dir = "desc";
                    switching = true;
                }}
            }}
        }}

        function filterSuspicious() {{
            var table = document.getElementById("procTable");
            var checkbox = document.getElementById("showSuspiciousOnly");
            var rows = table.tBodies[0].rows;
            for (var i = 0; i < rows.length; i += 2) {{ // Iterate by 2 for main row + details row
                var isSuspicious = rows[i].classList.contains('suspicious');
                if (checkbox.checked && !isSuspicious) {{
                    rows[i].style.display = 'none';
                    rows[i + 1].style.display = 'none'; // Hide details row too
                }} else {{
                    rows[i].style.display = '';
                    rows[i + 1].style.display = 'none'; // Ensure details are hidden when unfiltered
                    rows[i].querySelector("button.details-toggle").textContent = "▶"; // Reset toggle icon
                }}
            }}
        }}
    </script>
    """
    return html_content


def generate_process_persistence_report(app_instance: Any, helpers: Any, browser_preference: str = "System Default"):
    """
    Gathers running processes, analyzes them for suspicious activity,
    and generates an HTML report.
    """
    app_instance.log_output("\n--- Generating Process Persistence Report ---")
    
    pids = psutil.pids()
    # Use a ThreadPoolExecutor for concurrent scanning of processes
    with concurrent.futures.ThreadPoolExecutor(max_workers=os.cpu_count() or 4) as executor:
        # Pass app_instance to scan_process for logging within threads
        futures = [executor.submit(scan_process, pid, app_instance) for pid in pids]
        # Collect results, filtering out None values (e.g., due to NoSuchProcess)
        results = [f.result() for f in concurrent.futures.as_completed(futures) if f.result()]

    html_body = _generate_persistence_html_content(results)

    helpers.generate_report_html(
        app_instance, 
        app_instance.suspect_computer_name, 
        "Process_Persistence_Report.html", 
        "Process Persistence & Suspicious Activity Report", 
        html_body,
        browser_preference=browser_preference
    )

